}
k1 <- abs(moments(ndrp)[4])
k2 <- abs(moments(pdrp)[4])
#calculate s multiplier
s1 <- 3.8+0.35*log(k1)+0.045*log(k1)^2   +0.75
s2 <- 3.8+0.35*log(k2)+0.045*log(k2)^2   +0.75
#construct piik matrix
piik <- c(median(ndrp),median(pdrp))
#Expand piik to take all values
piik <- rbind (piik, matrix(c(NA,NA,NA,NA),nrow=2,ncol=2))
#fill in the values
piik[2, 1] <-  piik[1, 1] -  mad(ndrp) * s1 #leftmost extreme (start of neg band)
piik[2, 2] <-  piik[1, 2] + mad(pdrp) * s2 #rigthmost extreme (end of pos band)
piik[3, 1] <-  piik[1, 1] + mad(ndrp) * s1 #first inner extreme (end of the neg band)
piik[3, 2] <-  piik[1, 2] - mad(pdrp) *s2 #second inner extreme (start of the pos band)
#we also need to add a column do 'piek' for compatibility's sake, position depends on whether outlers are pos or neg
if(length(ndrp) > length(pdrp)){
piek <- cbind(piek, c(krn[1, which.min((krn[2, ]-piik[1, 2])^2)], piek[2, ]/100, piik[1, 2]))
}else{
piek <- cbind(c(krn[1, which.min((krn[2, ]-piik[1, 1])^2)], piek[2, ]/100, piik[1, 1]), piek)
} #END piek update
#We now calculate the threshold for counting positives
tresh <- piik[1, 1] + (s1 + 1/2 * s1) * mad(ndrp)
# Quick Remedy to bug : One Population detected & tresh is NA or tresh is in positive cloud
tresh.bup1 <- min(piek[3,]) + 0.4 * abs(diff(piek[3,]))  #minimum peak + 40 % empty bandwidth
tresh.bup2 <- min(dal[3 ,which(dal[3, ] > piik[1, 1])])  #minimum of all valleys larger than neg peak
}else{ #no outliers: we give up
fail <- 1 #notify failure
} #end of no outlier case
} #END of ONE population case
} #END of the THREE population 'if - else'
#from here on it's the same for all cases, we start with:
##################################################################################
##Second major control point: checks if 'tresh' exists (if not: only one population, no outliers)
##################################################################################
if(exists("tresh")){##Control LVL 2
#if we have a threshold we can continue, we start with a few more controls:
##################################################################################
##third to fifth control points: checks for stability reasons
##################################################################################
#in case of failure (tresh is NA) we fal back on the backup threshold
if(is.na(tresh)){##Control LVL 3
if(!isTRUE(silent)){message("WARNING!: threshold placement failed")
message("Check data, arbitrary threshold was set")
message("---------")}
tresh <-  tresh.bup1
## if tresh is NA the piik is as well, we redo all the calculations:
ndrp <- drp[which(drp < tresh)]
pdrp <- drp[which(drp > tresh)]
#construct piik matrix
piik <- c(median(ndrp),median(pdrp))
#Expand piik to take all values
piik <- rbind (piik, matrix(c(min(ndrp),max(pdrp),max(ndrp),min(pdrp)),nrow=2,ncol=2, byrow = T))
}##Control LVL 3 END
##############################
#excessive rain can make the standard deviations go haywire
#we build in this simple check to make sure the treshold is not placed into the positive band
print("Hello po ")
print(piik)
if(tresh > piik[3, 2]){ ##Control LVL 4
if(!isTRUE(silent)){message("WARNING!: threshold inside positve cloud")
message("Forced lower threshold, not based on population parameters")
message("---------")}
tresh <-  tresh.bup2
}##Control LVL 4 END
##############################
#another problem related to standard deviations is overlapping bounderies
#check : upper neg boundary is situated above lover pos boundary?
if(piik[3, 1] > piik[3, 2]){##Control LVL 5
if(!isTRUE(silent)){message("WARNING!: population boundary overlap")
message("boundaries rewritten, not based on population parameters")
message("---------")}
#we can use the 'valleys' returned by findpeaks to draw new population bounderies
#we take the valley closest to the corresponding peak as the new boundary
piik[3, 1] <- min(dal[3 ,which(dal[3, ] > piik[1, 1])])  #minimum of all valleys larger than neg peak
piik[3, 2] <- max(dal[3 ,which(dal[3, ] < piik[1, 2])])  #maximum of all valleys smaller than pos pesk
}##Control LVL 5 END
##################################################################################
#we can now start the trivial calculations:
##################################################################################
#count the raindrops (i.e. the population of the 'clearance band' between the positive and negative band)
#again to avoid including negatives in the rain we use the treshold in stead of the peak base
#rain <- length(which(drp > piik[3, 1] & drp < piik[3, 2]))
rain <- length(which(drp > tresh & drp < piik[3, 2]))
#split in positive and negatives so we can apply colours on the plot
pdrp <- drp[which(drp>tresh)]
ndrp <- drp[which(drp<=tresh)]
classification <- rep("neg", length(drp))
classification[which(drp>tresh)] <- "pos"
if(showRain){
classification[which(drp > tresh & drp < piik[3, 2])] <- "rain"
}
return(classification)
}
}
}
# flou <- read.csv("sim_concB_R4_rep1.csv")
cloudyClassifier(flou[,2], silent = FALSE)
topX
# flou <- read.csv("sim_concB_R4_rep1.csv")
x <- cloudyClassifier(flou[,2], silent = FALSE)
sum(x == "pos")
sum(x == "neg")
## Main function ###############
#########################################################################################################
cloudyClassifier <- function (drp, showRain = FALSE, silent = TRUE){
##################################################################################
#colorschemes for the colorblind##################################################
two.color <- c(rgb(68,  140,  59, maxColorValue = 255), rgb(117, 170,  93, maxColorValue = 255), rgb(160, 204, 124, maxColorValue = 255),
rgb(219, 255, 182, maxColorValue = 255), rgb(216, 196, 213, maxColorValue = 255), rgb(192, 160, 202, maxColorValue = 255),
rgb(171, 124, 189, maxColorValue = 255), rgb(133,  84, 168, maxColorValue = 255))
spectral  <- c(rgb(241,  17,  39, maxColorValue = 255), rgb(255, 119,  40, maxColorValue = 255), rgb(255, 163,  41, maxColorValue = 255),
rgb(253, 208,  42, maxColorValue = 255), rgb(245, 255,  46, maxColorValue = 255), rgb(139, 205, 255, maxColorValue = 255),
rgb(132, 132, 223, maxColorValue = 255), rgb(123, 168, 194, maxColorValue = 255), rgb(110,   9, 123, maxColorValue = 255))
##################################################################################
#Internal function: PEAKFINDER (finds all local minima/maxima in a range of data )
##################################################################################
findpeaks <- function(vec, bw = 1, x.coo = c(1:length(vec))){  #where bw = is box width, setting the sensitivity of the search
###set all vectors to null
pos.x.max <- NULL ;	pos.y.max <- NULL ;	pos.x.min <- NULL ;	pos.y.min <- NULL
###Start of for loop:    we walk down the vector with a window of size "bw"
for(i in 1:(length(vec)-1)){
#check if we have reached the end of the vector
if((i+1+bw)>length(vec)){sup.stop <- length(vec)}else{sup.stop <- i+1+bw}
#check if we are at beginning of the vector
if((i-bw) < 1){inf.stop <- 1}else{inf.stop <- i-bw}
#select window in two parts: values beyond i (superior), and values before i (inferior)
subset.sup <- vec[(i+1):sup.stop]
subset.inf <- vec[inf.stop:(i-1)]
##############################################################
#are ALL trailing data smaller than i?
is.max   <- sum(subset.inf > vec[i]) == 0
#are ALL leading data smaller than i?
is.nomin <- sum(subset.sup > vec[i]) == 0
#are ALL trailing data larger than i?
no.max   <- sum(subset.inf > vec[i]) == length(subset.inf)
#are ALL leading data larger than i?
no.nomin <- sum(subset.sup > vec[i]) == length(subset.sup)
##############################################################
#a maximum is found if  all data before and after i are smaller than i
if(is.max & is.nomin){
pos.x.max <- c(pos.x.max, x.coo[i])
pos.y.max <- c(pos.y.max, vec[i])
}
#a maximum is found if  all data before and after i are larger than i
if(no.max & no.nomin){
pos.x.min <- c(pos.x.min, x.coo[i])
pos.y.min <- c(pos.y.min, vec[i])
}
}#end of for loop
###Output
return(list("max.X" = pos.x.max, "max.Y" = pos.y.max, "min.X" = pos.x.min, "min.Y" = pos.y.min))}
#End if peakfinder function########################################################
##################################################################################
require(SuppDists)     #required for the 'moments()' function
##################################################################################
## ACTUAL FUNCTION START #########################################################
##################################################################################
#pre-perp: remove NA from data, inspect bandwidth
drp <- na.omit(drp)
fail <- 0 #create failure tracker
pops <- 0 #create population tracker
#be sure bandwidth for kernel density is at least 50
temp <- bw.nrd0(drp)
if(temp < 50){
temp <- 50
}
#kernel density estimation
krn <- density(drp, bw = temp)
krn <- rbind(krn$y, krn$x)
#we use findpeaks with a high bandwith to single out the populations
piek <- findpeaks(krn[1, ], bw=20)$max.X
dal <- findpeaks(krn[1, ], bw=20)$min.X
piek <- rbind(piek, krn[1, piek])    #add peak heights
dal <- rbind(dal,  krn[1,  dal])
piek <- rbind(piek, krn[2, piek[1,]])#add peak x-locations
dal <- rbind(dal,  krn[2,  dal[1,]])
#we also remove all peaks that are smaller than 1% of the max peak height.
#Outlying fluorescence values will otherwise cause insignificantly small peaks that screw with algorithm robustness
if(any(piek[2,] < max(piek[2,])/100)){
piek <- piek[, -which(piek[2,] < max(piek[2,])/100)]
#make sure shit didn't vectorize
if(is.null(dim(piek))){
piek <- as.matrix(piek)
}
}
##################################################################################
##First major control point: we only proceed if there are no NA
if(!any(is.na(piek))){ ##Control LVL 1
##################################################################################
#First, we check for three or more populations
if(length(piek[1,]) >= 3){
#post warning
message("WARNING: three population detected")
message("---------")
#set the number of populations
pops <- length(piek[1,])
#split total bandwidth in three parts, using lower and upper for neg and pos populations
temp <- c(max(piek[3, ]) - diff(tail(sort(piek[3, ]), n = 2))/2,      #limit between pos and middle
min(piek[3, ]) + diff(head(sort(piek[3, ]), n = 2))/2)      #limit between neg and middle
#The presence of the 'middle' population prevents us from using the iterative approach to set the standard deviations
#instead, we directly calculate the final values from the limits we've set
ndrp <- drp[which(drp < temp[2])]
pdrp <- drp[which(drp > temp[1])]
#calculate kurtosis of droplets
k1 <- abs(moments(ndrp)[4])
k2 <- abs(moments(pdrp)[4])
#calculate s multiplier
s1 <- 3.8+0.35*log(k1)+0.045*log(k1)^2   +0.75
s2 <- 3.8+0.35*log(k2)+0.045*log(k2)^2   +0.75
#construct piik matrix
piik <- c(median(ndrp),median(pdrp))
#Expand piik to take all values
piik <- rbind (piik, matrix(c(NA,NA,NA,NA),nrow=2,ncol=2))
#fill in the values
piik[2, 1] <-  piik[1, 1] -  mad(ndrp) * s1 #leftmost extreme (start of neg band)
piik[2, 2] <-  piik[1, 2] + mad(pdrp) * s2 #rigthmost extreme (end of pos band)
piik[3, 1] <-  piik[1, 1] + mad(ndrp) * s1 #first inner extreme (end of the neg band)
piik[3, 2] <-  piik[1, 2] - mad(pdrp) *s2 #second inner extreme (start of the pos band)
#Extra check: the start of the pos band should not fall in the 'middle' peak,
#             if so we replace it with the minimum between both peaks
if(piik[3, 2] <  temp[1]){
piik[3, 2] <- max(dal[3 ,which(dal[3, ] < piik[1, 2])])  #maximum of all valleys smaller than pos pesk
}
#We now calculate the threshold for counting positives
tresh <- piik[1, 1] + (s1 + 1/2 * s1) * mad(ndrp)
#should the threshold fail, we provide a backup
tresh.bup1 <- temp[2]
tresh.bup2 <- max(dal[3 ,which(dal[3, ] < piik[1, 2])])  #maximum of all valleys smaller than pos pesk
#finally, for compatibility's sake, we also reduce the original peak matrix to only contain the positive an negative populations
piek <- piek[, c(which.min(piek[3, ]), which.max(piek[3, ]))]
}else{ # We have changed 'piek' to only contain two populations, we must skip the other possibilities to prevent re-analysis
#END of THREE population case
##################################################################################
#If not three, check for exactly two populations (Standard algorithm)
if(length(piek[1,]) == 2){
#set the number of populations
pops <- 2
#get started on the main population matrix
piik <- piek[3, ]
#decide on a temporarly divider for the peaks
kkn <- max(piek[3, ]) - diff(piek[3, ])/2
#We find the peak base by first estimaging the standard deviation as 1/2 of the width of the peak at 0.6065 percent of the max height
#first we find the y-location (60.65% height) for both peaks
baes <- (dnorm(1)/dnorm(0)) * piek[2, ]
# Quick remedy to bug when there is none in the Top 10 < kkn is < piik[1]
TopX <- 10
repeat{
temp <- head(krn[2, which(krn[2, ] < kkn)][order((krn[1, which(krn[2, ] < kkn)] - baes[1])^2)] , n = TopX) #select 10 possible crossing candidates in the first half of the data (necessary as the data are discrete)
temp <- c(temp[which(temp < piik[1])][order(temp[which(temp < piik[1])]-piik[1], decreasing = T)[1]],
temp[which(temp > piik[1])][order(temp[which(temp > piik[1])]-piik[1])[1]])#take the ones nearest to the peak (one larger and one smaller)
TopX <- TopX + 1
if(all(!is.na(temp))){
break
}
}
baes <- rbind(baes,temp)
# Quick remedy to bug when there is none in the Top 10 > kkn is < piik[2]
TopX <- 10
repeat{
temp <- head(krn[2, which(krn[2, ] > kkn)][order((krn[1, which(krn[2, ] > kkn)] - baes[1, 2])^2)], n = TopX) #select 10 possible crossing candidates in the second half of the data
temp <- c(temp[which(temp < piik[2])][order(temp[which(temp < piik[2])] - piik[2], decreasing = T)[1]],
temp[which(temp > piik[2])][order(temp[which(temp > piik[2])] - piik[2])[1]])#take the ones nearest to the peak (one larger and one smaller)
TopX <- TopX + 1
if(all(!is.na(temp))){
break
}
}
baes <- rbind(baes,temp)
#Expand piik to take all values
piik <- rbind (piik, matrix(c(NA,NA,NA,NA),nrow=2,ncol=2))
#The higher the kurtosis of the clouds the more sigmas we need to cover 99% of all the droplets, we start with standard values (4) and update below
s1 <- 4
s2 <- 4
#let's populate the population matrix with the population boundaries
piik[2, 1] <-  piik[1, 1] - diff(baes[2, ])/2 * s1 #leftmost extreme (start of neg band)
piik[2, 2] <-  piik[1, 2] + diff(baes[3, ])/2 * s2 #rigthmost extreme (end of pos band)
piik[3, 1] <-  piik[1, 1] + diff(baes[2, ])/2 * s1 #first inner extreme (end of the neg band)
piik[3, 2] <-  piik[1, 2] - diff(baes[3, ])/2 * s2 #second inner extreme (start of the pos band)
#allright, using this rough delimination of the clouds we can calculate more accurate values
#by iterating the update process three times (i.e. use current estimate to calculate pos and neg,
# then recaculte sd and re-delimite bands). Three iterations is generaly enough to reach
# stability in the first decimal place.
for ( i  in 1 : 3 ) {
#split in positive and negatives
pdrp <- drp[which(drp >= piik[3, 2] & drp <= piik[2, 2])]
ndrp <- drp[which(drp >= piik[2, 1] & drp <= piik[3, 1])]
#calculate kurtosis of droplets
k1 <- abs(moments(ndrp)[4])
k2 <- abs(moments(pdrp)[4])
#update s multiplier
s1 <- 3.8+0.35*log(k1)+0.045*log(k1)^2   +0.75
s2 <- 3.8+0.35*log(k2)+0.045*log(k2)^2   +0.75
#update
piik[2, 1] <-  piik[1, 1] - mad(ndrp) * s1 #leftmost extreme (start of neg band)
piik[2, 2] <-  piik[1, 2] + mad(pdrp) * s2 #rigthmost extreme (end of pos band)
piik[3, 1] <-  piik[1, 1] + mad(ndrp) * s1 #first inner extreme (end of the neg band)
piik[3, 2] <-  piik[1, 2] - mad(pdrp) * s2 #second inner extreme (start of the pos band)
#advance the cycle
i <- i + 1
}#END of the iterative update
#We now calculate the threshold for counting positives
tresh <- piik[1, 1] + (s1 + 1/2 * s1) * mad(ndrp)
#should the threshold fail, we provide a backups
tresh.bup1 <- min(piek[3,]) + 0.4 * abs(diff(piek[3,]))  #minimum peak + 40 % empty bandwidth
tresh.bup2 <- min(dal[3 ,which(dal[3, ] > piik[1, 1])])  #minimum of all valleys larger than neg peak
}#END of the two population procedure
##################################################################################
#Last option: there is only one population (single peak)
#this case requres a bit more inspection to make sure we didn't overlook the some (few) positives or negatives
if(length(piek[1,]) == 1){
#set the number of populations
pops <- 1
#Since there still may be few negatives / positives that got smoothed out.
#We should be able to detect them as 'outliers' from the single population
#therefore we calculate z-scores for all droplets
zs <- (drp - median(drp))/mad(drp)
k1 <- abs(moments(drp)[4])
s1 <- 4.55 + 0.35 * log(k1) + 0.045 * log(k1)^2
#check for outliers and check if they sare higher or lower to decide if the pop is pos or neg
#Also make sure there is more than one outlier, otherwise none of the below makes sense
if(any(abs(zs) > 1.5 * s1) & length(which(abs(zs) > 1.5 * s1)) >= 2){
#we have outliers!
#set the number of populations
pops <- pops + 1
#we now decide if they are positive or negative and produce threshold and piik matrix
if(sum(drp[which(abs(zs) >= s1)]) > 0){ #outliers have higher fluorescence and are thus positive
pdrp <- drp[which(abs(zs) >= 1.5 * s1)]
ndrp <- drp[which(abs(zs) <  1.5 * s1)]
}else{ #outliers have lower fluorescence and are thus negative
pdrp <- drp[which(abs(zs) <  1.5 * s1)]
ndrp <- drp[which(abs(zs) >= 1.5 * s1)]
}
k1 <- abs(moments(ndrp)[4])
k2 <- abs(moments(pdrp)[4])
#calculate s multiplier
s1 <- 3.8+0.35*log(k1)+0.045*log(k1)^2   +0.75
s2 <- 3.8+0.35*log(k2)+0.045*log(k2)^2   +0.75
#construct piik matrix
piik <- c(median(ndrp),median(pdrp))
#Expand piik to take all values
piik <- rbind (piik, matrix(c(NA,NA,NA,NA),nrow=2,ncol=2))
#fill in the values
piik[2, 1] <-  piik[1, 1] -  mad(ndrp) * s1 #leftmost extreme (start of neg band)
piik[2, 2] <-  piik[1, 2] + mad(pdrp) * s2 #rigthmost extreme (end of pos band)
piik[3, 1] <-  piik[1, 1] + mad(ndrp) * s1 #first inner extreme (end of the neg band)
piik[3, 2] <-  piik[1, 2] - mad(pdrp) *s2 #second inner extreme (start of the pos band)
#we also need to add a column do 'piek' for compatibility's sake, position depends on whether outlers are pos or neg
if(length(ndrp) > length(pdrp)){
piek <- cbind(piek, c(krn[1, which.min((krn[2, ]-piik[1, 2])^2)], piek[2, ]/100, piik[1, 2]))
}else{
piek <- cbind(c(krn[1, which.min((krn[2, ]-piik[1, 1])^2)], piek[2, ]/100, piik[1, 1]), piek)
} #END piek update
#We now calculate the threshold for counting positives
tresh <- piik[1, 1] + (s1 + 1/2 * s1) * mad(ndrp)
# Quick Remedy to bug : One Population detected & tresh is NA or tresh is in positive cloud
tresh.bup1 <- min(piek[3,]) + 0.4 * abs(diff(piek[3,]))  #minimum peak + 40 % empty bandwidth
tresh.bup2 <- min(dal[3 ,which(dal[3, ] > piik[1, 1])])  #minimum of all valleys larger than neg peak
}else{ #no outliers: we give up
fail <- 1 #notify failure
} #end of no outlier case
} #END of ONE population case
} #END of the THREE population 'if - else'
#from here on it's the same for all cases, we start with:
##################################################################################
##Second major control point: checks if 'tresh' exists (if not: only one population, no outliers)
##################################################################################
if(exists("tresh")){##Control LVL 2
#if we have a threshold we can continue, we start with a few more controls:
##################################################################################
##third to fifth control points: checks for stability reasons
##################################################################################
#in case of failure (tresh is NA) we fal back on the backup threshold
if(is.na(tresh)){##Control LVL 3
if(!isTRUE(silent)){message("WARNING!: threshold placement failed")
message("Check data, arbitrary threshold was set")
message("---------")}
tresh <-  tresh.bup1
## if tresh is NA the piik is as well, we redo all the calculations:
ndrp <- drp[which(drp < tresh)]
pdrp <- drp[which(drp > tresh)]
#construct piik matrix
piik <- c(median(ndrp),median(pdrp))
#Expand piik to take all values
piik <- rbind (piik, matrix(c(min(ndrp),max(pdrp),max(ndrp),min(pdrp)),nrow=2,ncol=2, byrow = T))
}##Control LVL 3 END
##############################
#excessive rain can make the standard deviations go haywire
#we build in this simple check to make sure the treshold is not placed into the positive band
print("Hello po ")
print(piik)
if(tresh > piik[3, 2]){ ##Control LVL 4
if(!isTRUE(silent)){message("WARNING!: threshold inside positve cloud")
message("Forced lower threshold, not based on population parameters")
message("---------")}
tresh <-  tresh.bup2
}##Control LVL 4 END
##############################
#another problem related to standard deviations is overlapping bounderies
#check : upper neg boundary is situated above lover pos boundary?
if(piik[3, 1] > piik[3, 2]){##Control LVL 5
if(!isTRUE(silent)){message("WARNING!: population boundary overlap")
message("boundaries rewritten, not based on population parameters")
message("---------")}
#we can use the 'valleys' returned by findpeaks to draw new population bounderies
#we take the valley closest to the corresponding peak as the new boundary
piik[3, 1] <- min(dal[3 ,which(dal[3, ] > piik[1, 1])])  #minimum of all valleys larger than neg peak
piik[3, 2] <- max(dal[3 ,which(dal[3, ] < piik[1, 2])])  #maximum of all valleys smaller than pos pesk
}##Control LVL 5 END
##################################################################################
#we can now start the trivial calculations:
##################################################################################
#count the raindrops (i.e. the population of the 'clearance band' between the positive and negative band)
#again to avoid including negatives in the rain we use the treshold in stead of the peak base
#rain <- length(which(drp > piik[3, 1] & drp < piik[3, 2]))
rain <- length(which(drp > tresh & drp < piik[3, 2]))
#split in positive and negatives so we can apply colours on the plot
pdrp <- drp[which(drp>tresh)]
ndrp <- drp[which(drp<=tresh)]
classification <- rep("neg", length(drp))
classification[which(drp>tresh)] <- "pos"
if(showRain){
classification[which(drp > tresh & drp < piik[3, 2])] <- "rain"
}
return(classification)
}
}
}
# flou <- read.csv("sim_concB_R4_rep1.csv")
# x <- cloudyClassifier(flou[,2], silent = FALSE)
#
# main("EM_tskew")
# main("umbrella")
# main("EM_t")
main("cloudy")
df_est <- read.csv("D:/~Masters/~ MS-STAT/~THESIS/Code/Estimates_simulated_combined.csv")
library(ggplot2)
df_est$Attribute <- as.factor(df_est$Attribute)
df_est$Attribute <- relevel(x = df_est$Attribute, ref = "umbrella")
df_est$conc2 <- as.factor(df_est$conc)
p <- ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
ggsave(p, filename="Estimates_simulated_combined.png", device="png", width=10, height=7)
getwd()
str(df_est)
df_est$rain_setting <- as.factor(df_est$rain_setting)
ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
df_est <- read.csv("D:/~Masters/~ MS-STAT/~THESIS/Code/Estimates_simulated_combined.csv")
library(ggplot2)
df_est$Attribute <- as.factor(df_est$Attribute)
df_est$Attribute <- relevel(x = df_est$Attribute, ref = "umbrella")
df_est$conc2 <- as.factor(df_est$conc)
df_est$rain_setting <- as.factor(df_est$rain_setting)
ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
str(df_est)
df_est$Value <- as.numeric(df_est$rain_setting)
df_est <- read.csv("D:/~Masters/~ MS-STAT/~THESIS/Code/Estimates_simulated_combined (v2).csv")
library(ggplot2)
df_est$Attribute <- as.factor(df_est$Attribute)
df_est$Attribute <- relevel(x = df_est$Attribute, ref = "umbrella")
df_est$conc2 <- as.factor(df_est$conc)
df_est$rain_setting <- as.factor(df_est$rain_setting)
df_est$Value <- as.numeric(df_est$rain_setting)
ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
str(df_est)
as.numeric("0.9")
df_est <- read.csv("D:/~Masters/~ MS-STAT/~THESIS/Code/Estimates_simulated_combined (v2).csv")
library(ggplot2)
df_est$Attribute <- as.factor(df_est$Attribute)
df_est$Attribute <- relevel(x = df_est$Attribute, ref = "umbrella")
df_est$conc2 <- as.factor(df_est$conc)
df_est$rain_setting <- as.factor(df_est$rain_setting)
df_est$Value <- as.numeric(df_est$Value)
ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
p <- ggplot(df_est, aes(x=Attribute, y=Value, colour=conc2)) +
geom_boxplot() +
labs(x = 'Method', y = 'DNA Concentration') +
geom_hline(aes(yintercept=conc), color="black", linetype="dashed") +
facet_grid(rows = vars(conc), cols = vars(rain_setting),scales = "free_y", ) +
theme_light() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
ggsave(p, filename="Estimates_simulated_combined.png", device="png", width=10, height=7)
ggsave(p, filename="Estimates_simulated_combined 2.png", device="png", width=10, height=12)
